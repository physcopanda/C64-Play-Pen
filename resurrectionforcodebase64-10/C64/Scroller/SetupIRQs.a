!ifdef Scroller_FullScreen {
!ifdef IRQOpenBorders {
scorePanelPos1 = $f4	; The place to start the open border code if it is enabled. Also the bottom of the screen IRQ.
scorePanelPos2 = $fa	; The place for the second part to the open border code if it is enabled.
} else {
scorePanelPos1 = $f8	; The place to start the bottom of the screen IRQ.
}
} else {
scorePanelPos1 = 205	; The place to start the split, 9 lines above scorePanel2Pos. Turns off the screen, sprites, resets scroll coordinates, graphics colours and mode etc
scorePanelPos2 = 212	; The line above where we want to display the real panel. Just enough time to set V pos and enable the screen
}


; MPi: TODO: Think about initialising this in the init?
ScreenVisibleHi !by $c8
IRQ_InGameMode !by 0

!zn
SetupIRQs
	sei
	; Setup raster IRQ
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi
	lda #1
	sta VIC2InteruptControl
	lda #$0
	sta VIC2Raster
	sta NMINotTimerGenerated
	lda #$1b
	sta VIC2ScreenControlV

	+MACROAckRasterIRQ_A

	; Setup NMI
	lda #<ScrollerNMI1
	sta KERNALNMIServiceRoutineLo
	lda #>ScrollerNMI1
	sta KERNALNMIServiceRoutineHi
	; Turn on NMI generated by timer B
	lda #$81
	sta CIA2InterruptControl

	lda #1
	sta IRQ_InGameMode

	+MACROAckAllIRQs_A

	cli
	rts

!zn
SetupIRQsForTitleScreen
	sei
	lda #1
	sta VIC2InteruptControl
	jsr Multiplex_StartTopInterrupt
	+MACROAckAllIRQs_A

	lda #0
	sta IRQ_InGameMode

	cli
	rts

; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
ScrollerNMI1
!ifdef Scroller_DebugNMIBorder {
	dec VIC2BorderColour
}
	sta NMI_areg
;	stx NMI_xreg
	sty NMI_yreg

	; Check to see if this NMI happened due to the timer happening.
	; If not then we assume restore was pressed so we flag it for the game mainline to quit.
	lda CIA2InterruptControl
	and #1
	bne .wasTimer
	lda #1
	sta NMINotTimerGenerated
	; Don't do any other work since we are not timer generated.
	jmp .retNMI
.wasTimer
	; The NMI CIA timer setup code will need changing if the below code significantly changes cycle count.
!ifdef IRQOpenBorders {
!ifdef Scroller_IsHorizontal {
	ldy #%11000
} else {
	; Pre-calculate the screen control V register for faster setting
!ifdef Scroller_MultiDirection {
	lda IRQUsedScreenScrollY
} else {
	lda IRQUsedScreenScrollPos
}
	ora #%10000
	tay
}
	; Switch banks to start displaying non-blank sprites and also the correct character set and screen data
	lda #%00
	; Store the bank first
	sta CIA2PortASerialBusVICBank
	; "Enable" the screen by switching off bitmap/ECM mode
	sty VIC2ScreenControlV
}

.retNMI
	lda NMI_areg
;	ldx NMI_xreg
	ldy NMI_yreg

!ifdef Scroller_DebugNMIBorder {
	inc VIC2BorderColour
}
	rti
NMI_areg !by 0
NMI_xreg !by 0
NMI_yreg !by 0

topIRQDone				!by 0
bottomMultiplexIRQDone	!by 0
panelIRQDone			!by 0

NMINotTimerGenerated	!by 0

; Updated by the mainline
!ifdef Scroller_MultiDirection {
topScreenScrollX		!by 0
topScreenScrollY		!by 0
} else {
topScreenScrollPos		!by 0
}
topScreenBank			!by 0

!ifdef Scroller_MultiDirection {
IRQUsedScreenScrollY !by 0
} else {
IRQUsedScreenScrollPos !by 0
}


!zn
IrqTopOfScreen
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	; We store these with the multiplex temp registers because we call Multiplex_maininterEx
	sta Multiplex_areg
	stx Multiplex_xreg
	sty Multiplex_yreg

	cld

!ifdef IRQOpenBorders {
	; Setup the NMI with a timer. An NMI is used because we don't want to mess around with
	; having another normal IRQ in the middle of the multiplexor code.
	; This code is sensitive to timing so make it happen first!
	lda #$7f
	sta CIA2InterruptControl
	lda #0
	sta CIA2TimerAControl
	sta CIA2TimerBControl
	; Ack any interrupts that have happened
	lda CIA2InterruptControl
	; Turn off timer A
	lda #0
	sta CIA2TimerAControl


!ifdef Scroller_IsHorizontal {
	; Reset timer B count
;	lda #$1b	; (49 pixels * 64 cycles) - $25 for timing adjustment for the NMI
;	sta CIA2TimerALo
;	lda #$c
;	sta CIA2TimerAHi

	; This opens up three more lines at the top of the screen increasing the play area slightly
	lda #$60	; (46 pixels * 64 cycles) - $20 for timing adjustment for the NMI
	sta CIA2TimerALo
	lda #$b
	sta CIA2TimerAHi
} else {
	; Depending on the screen scroll value adjust the NMI timer to help stablise the top screen split.
	; MPi :TODO: The number of sprites under the split is also important to the timing.
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
} else {
	lda topScreenScrollPos
}
	cmp #6
	bne .otherValues
	; Reset timer B count
	lda #$df	; (52 pixels * 64 cycles) - $21 for timing adjustment for the NMI
	sta CIA2TimerALo
	lda #$c
	sta CIA2TimerAHi
	jmp .turnOnTimer
.otherValues
	; Reset timer B count
	lda #$0a	; (52 pixels * 64 cycles) + $a for timing adjustment for the NMI
	sta CIA2TimerALo
	lda #$d
	sta CIA2TimerAHi
.turnOnTimer
}
	; Turn on timer A
	lda #$9						; Trigger timer A once only
	sta CIA2TimerAControl
	; Reset interrupt control for NMI so that if restore is pressed it only misses one frame.
	lda #$81
	sta CIA2InterruptControl
}

	; Then disable all the sprites
	lda #0
	sta VIC2SpriteEnable

	inc topIRQDone
	lda #0
	sta bottomMultiplexIRQDone
	sta panelIRQDone

!ifdef Scroller_IsHorizontal {
	lda topScreenScrollPos
	ora #%10000
	sta VIC2ScreenControlH
} else {
!ifdef Scroller_MultiDirection {
	lda topScreenScrollX
	ora #%10000
} else {
	lda #%11000
}
	sta VIC2ScreenControlH
}

!ifdef Scroller_IsHorizontal {
!ifdef IRQOpenBorders {
	; Blank the screen with bitmap/ECM but enable the screen character fetches at the scroll position
	lda #%1111000
	sta VIC2ScreenControlV
	; Make the VIC use bank $0000-$3fff for this top screen until we open the screen with the NMI
	lda #%11
	sta CIA2PortASerialBusVICBank
} else {
	lda #%11011
	sta VIC2ScreenControlV
	; Make the VIC use bank $c000-$ffff for this top screen
	lda #%00
	sta CIA2PortASerialBusVICBank
}
} else {
!ifdef IRQOpenBorders {
	; Blank the screen with bitmap/ECM but enable the screen character fetches at the scroll position
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
	sta IRQUsedScreenScrollY
} else {
	lda topScreenScrollPos
	sta IRQUsedScreenScrollPos
}
	ora #%1110000
	sta VIC2ScreenControlV
	; Make the VIC use bank $0000-$3fff for this top screen until we open the screen with the NMI
	lda #%11
	sta CIA2PortASerialBusVICBank
} else {
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
	sta IRQUsedScreenScrollY
} else {
	lda topScreenScrollPos
	sta IRQUsedScreenScrollPos
}
	ora #%10000
	sta VIC2ScreenControlV
	; Make the VIC use bank $c000-$ffff for this top screen
	lda #%00
	sta CIA2PortASerialBusVICBank
}
}

	; Graphics screen colours
	lda BackgroundFixedColours
	sta VIC2ScreenColour
	lda BackgroundFixedColours+1
	sta VIC2ExtraBackgroundColour1
!ifdef Scroller_LOTD {
	lda SpellEffectColour
} else {
	lda BackgroundFixedColours+2
}
	sta VIC2ExtraBackgroundColour2


	; Charset at $f000 and screens at whatever bank we want
	ldy #$c8
	lda topScreenBank
	beq .notUpperBank
	ldy #$cc
.notUpperBank
	sty ScreenVisibleHi
	clc
	adc #%10			; Skip over the charset
	asl					; Move up into the screen setup
	asl
	asl
	asl
	; No need to ora in 0 for the charset
	sta VIC2MemorySetup

!ifdef Scroller_MultiDirection { } else {
	lda #$ff
	sta VIC2SpriteMulticolour
}

!ifdef IRQOpenBorders {
	lda #%11
	sta CIA2PortASerialBusVICBank
}

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}

	jmp Multiplex_maininterEx

!zn
MultiplexExt_LastIRQ
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	lda IRQ_InGameMode
	bne .inGameMode

	lda #$ff
	sta VIC2Raster
	lda #<BottomTitleScreen
	sta KERNALIRQServiceRoutineLo
	lda #>BottomTitleScreen
	sta KERNALIRQServiceRoutineHi

	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	jmp Multiplex_AckExitInterrupt

.inGameMode
	cld

	lda #scorePanelPos1
	sta VIC2Raster
!ifdef Scroller_FullScreen {
	lda #<BottomBorder
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorder
	sta KERNALIRQServiceRoutineHi

!ifdef IRQOpenBorders {
	; Depending on the y scroll position we use slightly different bottom of the screen IRQs.
	; This helps to stablise the bottom split.
!ifdef Scroller_MultiDirection {
	ldy IRQUsedScreenScrollY
} else {
	ldy IRQUsedScreenScrollPos
}
	cpy #4
	bne .useMoreTime
	lda #<BottomBorderLessTime
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorderLessTime
	sta KERNALIRQServiceRoutineHi
.useMoreTime
}
} else {
	lda #<ScorePanel1
	sta KERNALIRQServiceRoutineLo
	lda #>ScorePanel1
	sta KERNALIRQServiceRoutineHi
}

	inc bottomMultiplexIRQDone

	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	jmp Multiplex_AckExitInterrupt


BottomTitleScreen
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore
	sty irqYStore

	cld									; Paranoia
	inc panelIRQDone

!ifdef Scroller_MultiDirection { } else {
	jsr TitleScreenAnimationHook
}
	jsr Multiplex_Sort
	jsr Multiplex_StartTopInterrupt

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore
	ldy irqYStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti



!ifdef Scroller_FullScreen {
; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
!ifdef IRQOpenBorders {
BottomBorderLessTime
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	sty irqYStore

	; Open the border by altering the screen height.
	; Also enable bitmap and extended colour mode to blank the opened screen and save having to use the last VIC2 bank for the normal opened border
	lda #%01111011
	sta VIC2ScreenControlV

	; We "display" (we are in bitmap/ECM mode and going to be in the open border hence "display") bank 0 because it is setup to display blank sprites for screens
	; $800 and $c00
	lda #%11
	sta CIA2PortASerialBusVICBank
	jmp .intoBottomBorder
}

BottomBorder
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	sty irqYStore

!ifdef IRQOpenBorders {
	; Open the border by altering the screen height.
	; Also enable bitmap and extended colour mode to blank the opened screen and save having to use the last VIC2 bank for the normal opened border
	ldy #scorePanelPos1
	lda #%01111011
.wait
	cpy VIC2Raster
	bcs .wait
	sta VIC2ScreenControlV

	; We "display" (we are in bitmap/ECM mode and going to be in the open border hence "display") bank 0 because it is setup to display blank sprites for screens
	; $800 and $c00
	lda #%11
	sta CIA2PortASerialBusVICBank

	; For the less time delayed bottom screen IRQ
.intoBottomBorder
	; Backup the last collision register state
	lda VIC2SpriteSpriteCollision
	sta .backupCollision

	; Switch off sprites, as much as they can be switched off while the VIC draws them :)
	lda #0
	sta VIC2SpriteEnable

	; Update the sprite y position first
	lda #8
	sta VIC2Sprite0Y
	sta VIC2Sprite1Y
	sta VIC2Sprite2Y
	sta VIC2Sprite3Y
	sta VIC2Sprite4Y
	sta VIC2Sprite5Y
	sta VIC2Sprite6Y
	sta VIC2Sprite7Y
} else {
!ifdef Scroller_MultiDirection { } else {
	lda VIC2SpriteSpriteCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}
}

	cld									; Paranoia
	inc panelIRQDone

!ifdef IRQOpenBorders {
	lda #scorePanelPos2
	sta VIC2Raster
	lda #<BottomBorder2
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorder2
	sta KERNALIRQServiceRoutineHi
} else {
	lda #0
	sta VIC2Raster
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi
}


	+MACROAckRasterIRQ_A
	lda irqAStore
	ldy irqYStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti


BottomBorder2
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	; Second part of opening the border, tweak the screen height again :)
	; Also note the hi raster bit position
	lda #%11110011
	sta VIC2ScreenControlV

	stx irqXStore

	; Now update the rest of the sprite pointers to display what we want
	; Turn off multi colour here so we don't get rubbish at the bottom of the screen sprite data.
	; If this is done earlier in the raster the timing is slightly wrong
	lda #0
	sta VIC2SpriteMulticolour

	; Here there is more raster time.
	lda #%11000000
	sta VIC2SpriteXMSB
	lda #44
	clc
	sta VIC2Sprite0X
	adc #24
	sta VIC2Sprite1X
	adc #24
	sta VIC2Sprite2X
	adc #24
	sta VIC2Sprite3X
	lda #204+24
	clc
	sta VIC2Sprite4X
	adc #24
	sta VIC2Sprite5X
	adc #24
	sta VIC2Sprite6X
	clc
	adc #24
	sta VIC2Sprite7X

	; Sprite score pointers. $fdc0-ffbf
	ldx #$f7
	stx Multiplex_spritepointer
	inx
	stx Multiplex_spritepointer+1
	inx
	stx Multiplex_spritepointer+2
	inx
	stx Multiplex_spritepointer+3
	inx
	stx Multiplex_spritepointer+4
	inx
	stx Multiplex_spritepointer+5
	inx
	stx Multiplex_spritepointer+6
	inx
	stx Multiplex_spritepointer+7

	; Get the sprite colours for each player
!ifdef Scroller_MultiDirection {
	lda #VIC2Colour_Red
} else {
	lda ObjectAnimations+$13
    and #15
    bne .colOK1
    ; SEUCK Uses red for player one score if the player colour is black
    lda #VIC2Colour_Red
.colOK1
}
	sta VIC2Sprite0Colour
	sta VIC2Sprite1Colour
	sta VIC2Sprite2Colour
	sta VIC2Sprite3Colour
!ifdef Scroller_MultiDirection {
	lda #VIC2Colour_Green
} else {
	lda ObjectAnimations+(AnimationType_Player2*$14)+$13
    and #15
    bne .colOK2
    ; SEUCK Uses blue for player two score if the player colour is black
    lda #VIC2Colour_Blue
.colOK2
}
	sta VIC2Sprite4Colour
	sta VIC2Sprite5Colour
	sta VIC2Sprite6Colour
	sta VIC2Sprite7Colour

	; Then enable all the sprites
	lda #255
	sta VIC2SpriteEnable

	; Now another raster for just above the bottom border sprites to switch to a sensible screen
	; and bank.
	; Any higher and the bottom of the score sprites start to get drawn as they come down from
	; the top of the screen.
	lda #7
	sta VIC2Raster
	lda #<BottomBorder3
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorder3
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti


BottomBorder3
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	; Make the VIC use bank $c000-$ffff screen $c800 for these border sprites
	lda #%00100000
	sta VIC2MemorySetup
	lda #%00
	sta CIA2PortASerialBusVICBank

	; Nothing to do with the border but instead we reset the hi bit of the next raster
	lda #%01110011
	sta VIC2ScreenControlV

!ifdef Scroller_MultiDirection { } else {
	lda .backupCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}

	lda #0
	sta VIC2Raster
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A
	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti

.backupCollision !by 0
} else {
; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
ScorePanel1
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	; Setting bitmap and ECM modes will cause VIC2 to display black as it gets confused but the internal counters will continue to count correctly.
	; Create our own char new line at this position
	lda #%01100111
	sta VIC2ScreenControlV

	; Switch to displaying our text screen in bank 0 to demo this
	lda #20
	sta VIC2MemorySetup
	lda #%11
	sta CIA2PortASerialBusVICBank

	; Graphics screen colours
	lda #0
	sta VIC2ScreenColour
	lda #3
	sta VIC2ExtraBackgroundColour1
	lda #4
	sta VIC2ExtraBackgroundColour2

	; Reset the screen X scroll and width
	lda #%00011000
	sta VIC2ScreenControlH

	cld									; Paranoia
	inc panelIRQDone

	lda #scorePanelPos2
	sta VIC2Raster
	lda #<ScorePanel2
	sta KERNALIRQServiceRoutineLo
	lda #>ScorePanel2
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A
	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti

!zn
ScorePanel2
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}

	sta irqAStore

	; Stabalise the screen now but still have the chars disabled by having bitmap and ECM on
	lda #%01111111
	sta VIC2ScreenControlV

	lda #scorePanelPos2+1
.nextLine
	cmp VIC2Raster
	bcs .nextLine

	; Turn on the screen
	lda #%00011111
	sta VIC2ScreenControlV

!ifdef Scroller_MultiDirection { } else {
	lda VIC2SpriteSpriteCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}

	; Make sure our sprites are off by the time the top interrupt comes along
	lda #0
	sta VIC2SpriteEnable
	; Start back at the top of the screen again
	sta VIC2Raster
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A

	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}

	rti
}	; ifdef Scroller_DebugIRQBorder {
