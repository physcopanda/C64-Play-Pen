; Demonstrates 8-way scrolling with 4x4 blocks, static score panel and sprite multiplexing
; Also demonstrates SEUCK data file compatibility.
!to "Scroller.prg", cbm
;!sal
!sl "Scroller.map"
!svl "Scroller.lbl"
!cpu 6510
!ct pet

!source "../stdlib/stdlib.a"
!source "ScrollerVars.a"
; Define what the multiplexor can use
Multiplex_VarBase	= scrollerDemo_endVars
Multiplex_spritepointer	= $cbf8
Multiplex_IRQServiceRoutineLo = KERNALIRQServiceRoutineLo;
Multiplex_IRQServiceRoutineHi = KERNALIRQServiceRoutineHi;
Multiplex_DiscardSpritesYPos=scorePanelPos1-1
Multiplex_items	= 32
!source "../SpriteMultiplexor/SpriteMultiplexorVars.a"
; Allows the mainline to start updating sprites earlier after the last multiplexor IRQ.
Multiplex_EnableEarlyOut = 1
; We have a lower raster for the screen split so we want to enable this functionality to give our
; IRQ time to get displayed.
Multiplex_OverflowRasterCheck1 = 1
Multiplex_OverflowRasterCheck2 = 1
; We have situations where sprites get bunched so this will allow the multiplexor to discard
; bunches of sprites and display more sprites in areas of heavy use.
Multiplex_BunchingCheck = 1

; Debug colour changes for the border
; Turning this on can cause some extra sprite flicker in tight formations because the colour
; changes take up extra time
;Multiplexor_DebugBorder = 1
; IRQs generated by this application and not those generated by the multiplexor.
;Scroller_DebugIRQBorder = 1
; NMIs generated by this application
;Scroller_DebugNMIBorder = 1
; Non-interrupt timings
;Scroller_DebugMainlineBorder = 1
;Scroller_DebugColourScrollTimings = 1
;Scroller_DebugScreenScrollTimings = 1

; Define this to demonstrate a multi-directional scroller.
; Undefine this to enable SEUCK data file compatibility.
;Scroller_MultiDirection = 1
!ifdef Scroller_MultiDirection { } else {

; New pixel accurate collision, always on.
Multiplex_LogCollisions = 1
Multiplexor_UpdateCollisionDetailsSoftEnable = 1

; Stop the multiplexor allocating static memory and use reserved memory instead
Multiplex_LeanAndMean = 1

; Example game names to use in ScrollerData.a are:
; Vertical scrolling
;GAME1__I.P00
;GAME2__I.P00
;GAME3__I.P00
;demo4.bin
;TSTCLLSN.P00
; Horizontal scrolling
;LOTD___I.P00
;SIDEWAYS.P00
;BAPHOMET.P00
;AEONDATA.P00

; Define this to use horizontal scrolling SEUCK instead
; Tested to be working with the "SIDEWAYS.P00" test.
;Scroller_IsHorizontal = 1

; Define this to cause the extended code for Legion of the Damned to be used
;Scroller_LOTD = 1

; Undefine this to only play music instead of sound effects during the game
Scroller_PlaySoundEffectsDuringGame = 1

; Define this to cause animating sprites to be displayed on the title screen instead of raster bar text
;TitleScreen_AnimatingSprites = 1

; Define this separately to Scroller_LOTD if you just want the linked enemy test enabled
; MPi: TODO: Double check with GAME1__I.P00 that the linked enemy test work only by the killable
; parts of the enemy causing the explosion. The linked first boss "wings" shouldn't be causing a kill.
Scroller_LinkedEnemyTest = 1

; Turns on the linked enemy test in LoTD if it isn't already enabled
; If Scroller_LOTD is enabled then turn on the linked enemy and horizontal flag by default
!ifdef Scroller_LOTD {
!ifdef Scroller_LinkedEnemyTest { } else {
Scroller_LinkedEnemyTest = 1
}
!ifdef Scroller_IsHorizontal {} else {
Scroller_IsHorizontal = 1
}
}


; MPi: TODO: Double check the sprite X and Y placement in normal SEUCK and horizontal SEUCK.
; Check final placement of enemies with scrolling levels that scroll to static screens and also
; just the static screens. Check push scroll as well.
; In the horizontal SEUCK games there is a chance the sprites are appearing one pixel offset from
; where they should be.
; I have a theory the problem is with the original SEUCK code where the sprites can lag one frame
; position behind a scroll. This does mean that there is no easy fix since while scrolling people
; might have placed their sprites to compensate for this one frame lag. In this case just make
; sure the sprite position is correct when the screen is static or stops scrolling (like that 
; scroll after a push scroll).
!ifdef Scroller_IsHorizontal {
; Horizontal SEUCK: Define this to not use the sprite Y adjustment code.
Scroller_NoSpriteYAdjust = 1
; Define this to enable the sprite X coord adjustment code.
Scroller_SpriteXAdjust = 1
}


}
;Enable full screen or use the lower screen split
Scroller_FullScreen = 1
; Enable the following line to allow the bottom and top borders to be opened and have sprites.
; This is only used when Scroller_FullScreen is enabled
!ifdef Scroller_FullScreen {
IRQOpenBorders = 1
}

; This code is post-build linked with a decompression stage so we don't use any BASIC sys start code here.
; Instead the start for the code is $400 which is quickly overwritten by other data once the
; real game code starts.
*=$400
	; Setup a nice stable blank screen and known machine state
	lda #ProcessorPortAllRAMWithIO
	jsr InitialiseMachine
	; Setup NMI because the initialise points to code that gets overwritten
	lda #<ScrollerNMI1
	sta KERNALNMIServiceRoutineLo
	lda #>ScrollerNMI1
	sta KERNALNMIServiceRoutineHi
	lda #0
	sta VIC2SpriteDoubleWidth
	sta VIC2SpriteDoubleHeight
	sta VIC2SpritePriority
	sta VIC2SpriteMulticolour
	; One time initialisation like moving memory around to the correct places and pre-calculation.
	jsr ScrollerDemoInitOneTimeData
	jmp ScrollEntry
	; This initialise code is here because we only use it once. Later the code is written
	; by the title screen display code.
!source "../stdlib/Initialise.a"
!source "OneTime.a"
	; The start of the real code. Memory from $400 to $fff is written by the title screen display code
*=$1000
!zn
ScrollEntry
	; The following can be called more than once if needed for a proper game type cycle
.l1
!ifdef Scroller_MultiDirection { } else {
	jsr DisplayTitleScreen
}
	jsr InitialiseGame
	jsr SetupIRQs
	jsr ScrollerDemoWaitTopIRQWithReSync
	jsr ScrollerDemoMainline
	jmp .l1

!source "SetupIRQs.a"
!source "ScrollMain.a"
; The multiplexor uses the MultiplexExt_LastIRQ label defined in "SetupIRQs.a"
!source "../SpriteMultiplexor/SpriteMultiplexor.a"

!source "ScrollerData.a"
